# 좌표 제거 이미지화를 통한 악성 안드로이드 애플리케이션 탐지(malware-dectection-with-ml)
- [0. Code List](#0-code-list)
- [1.개요](#1-개요)
  * [요약](#요약)
  * [연구배경](#연구배경)
  * [연구목표](#연구목표)
- [2.구현 및 실험](#2-구현-및-실험)
  * [실험 데이터 및 실험 방식](#실험-데이터-및-실험-방식)
  * [1) 전체 파일 이미지화 : IC(Incremental Coordinate)](#1-전체-파일-이미지화--icincremental-coordinate)
    + [(1) 좌표화](#1-좌표화)
    + [(2) 정규화](#2-정규화)
    + [(3) 실험결과](#3-실험결과)
  * [2) 좌표제거 방법](#2-좌표제거-방법)
    + [(1) 좌표분석 및 제안방법](#1-좌표분석-및-제안방법)
    + [(2) 구현 : (0,0) 제거](#2-구현--00-제거)
    + [(3) 구현 : (0,0), (255,255), (0,8), (32,32), (0,255) 제거](#3-구현--00-255255-08-3232-0255-제거)
    + [(4) 생성 이미지 비교](#4-생성-이미지-비교)
  * [3) 실험 결과 및 분석](#3-실험-결과-및-분석)
    + [(1) 실험 결과 비교](#1-실험-결과-비교)
    + [(2) 분석 및 한계점](#2-분석-및-한계점)
- [이미지화 구현 time issue](#이미지화-구현-time-issue)
- [참고문헌](#참고문헌)
- [세부 내용 참고](#세부-내용-참고)

## 0. Code List
- [01_bin_visualization.ipynb](https://github.com/khudev-ksw/malware-dectection-with-ml/blob/main/01_bin_visualization.ipynb)
    - 전체 파일 바이너리 이미지화 과정
- [02_coordinates_removal.ipynb](https://github.com/khudev-ksw/malware-dectection-with-ml/blob/main/02_coordinates_removal.ipynb)
    - 좌표 제거 방법 적용법 및 적용 전, 후 좌표, 이미지 변화 확인

## 1. 개요
### 요약
최근 스마트 디바이스 사용이 기하급수적으로 증가함에 따라 그를 노린 악성 프로그램이 증가하고 그 위협을 방지하는 것이 중요해지고 있다. 이러한 악성 프로그램 탐지에 머신러닝을 적용하여 기존의 방법으로 대응하기 힘들었던 신종 및 변종 악성 프로그램에 대응할 수 있게 되었다. 본 연구에서는 안드로이드 애플리케이션 파일 전체를 이미지화하고 좌표 제거 방법을 적용한 데이터 전처리를 통해 악성 안드로이드 애플리케이션 탐지 실험을 진행한다.

### 연구배경
기존의 악성 프로그램 판별 시스템은 악성 프로그램에 대한 시그니처를 생성하고 이를 기반으로 프로그램의 악성 유무를 판별하는 방식이었다. 하지만 이 방식은 실시간으로 나타나는 신종 또는 변종 악성 프로그램에 대응하는 것이 불가능하다는 단점이 있다.

최근 위와 같은 단점을 보완하기 위해 악성 프로그램 탐지 시스템에 ML(머신러닝)을 적용한 연구가 진행되고 있다. 악성 프로그램은 일반적으로 악성코드 패밀리에 따라 사용되는 라이브러리, 컴파일러 등에서 유사한 특징을 보이기 때문에 이러한 특징을 feature로 설정한 연구들이 진행되었고, 그 결과 악성 프로그램 분류가 가능했다 [1] [2]. 안드로이드 애플리케이션의 경우, 호출 API의 종류와 횟수 [3], 권한 정보 [4], 네트워크 트래픽 [5] 등에서 악성과 정상 애플리케이션간 차이점을 보였고, 이를 featrue로 설정하여 연구를 진행한 결과, 악성 애플리케이션 탐지가 가능했다.

### 연구목표
위와 같이 악성 프로그램 탐지에 ML을 적용하는 경우, 대부분 악성 프로그램의 특징을 별도의 과정을 통해 추출하고 feature로 설정하여 학습을 진행한다. 일반적인 악성코드의 경우, 전체 프로그램 파일을 input으로 하여 학습시키는 경우도 있지만 [1], 예측 정확도를 높이기 위해 악성코드의 PE헤더 [2] 등 프로그램의 특정 부분을 추출하여 학습시키는 경우가 많다. 특히, 국내에서 진행된 악성 안드로이드 애플리케이션 탐지 연구의 경우, 대부분 애플리케이션의 특정 부분을 추출하여 연구를 진행하고 있다.

하지만 특징 추출에는 비용이 발생한다. 만약 특징 추출이 아닌 파일 전체를 input으로 하여 분류가 가능해진다면 <u>**데이터 전처리 비용을 줄여 cost-effective한 시스템**</u>을 개발할 수 있다. 따라서 본 연구에서는 악성 안드로이드 애플리케이션 탐지에 있어서 특징 데이터 추출을 통해 feature를 설정하고 학습시킨 국내 대부분의 연구와 달리, <u>**애플리케이션 파일 전체를 전처리하여 만들어진 이미지를 사용하여 악성 애플리케이션을 탐지**</u>하는 연구를 진행한다. 특히, 이미지를 생성하는 전처리 과정에서 정확도를 높이기 위해 <u>**좌표 제거 방법**</u>을 제안한다. 좌표 제거 방법 적용 전, 후의 실험을 진행하여 결과를 분석하고, 마지막으로 본 연구의 한계점과 향후 연구 방향을 제시한다.


## 2. 구현 및 실험
### 실험 데이터 및 실험 방식
악성 안드로이드 애플리케이션 탐지 실험을 진행하기 위한 데이터에는 ‘2018 정보보호 R&D 데이터 챌린지 – AI기반 안드로이드 악성앱 탐지 트랙’ [6]의 KU-CISC2018-Android-Pre-Train, KU-CISC2018-Android-Pre-Test, KU-CISC2018-Android-Final-2nd-Test를 사용하였다. 이 중, 중복을 제외한 Normal application 8,024개, Malware application 3,829개, 총 11,853개의 애플리케이션을 사용하였다. Training set에는 80%인 9,483개를, Validation set에는 20%인 2,370개를 사용하였다.

[1]에 따르면 일반적인 프로그램에 IC 및 SO 기법을 사용하여 이미지 분류를 진행하였을 때, IC 기법을 적용한 프로그램의 악성 탐지 정확도가 더 높게 나왔다. 따라서 이미지화 방법으로는 2 Bytes를 (1 Byte, 1 Byte) = (0\~255, 0\~255) 좌표에 대응시키는 IC(Incremental Coordinate) 방법을 사용하였다.

실험은 Google Colab 일반 GPU 환경에서 이루어졌으며, 실험에 사용한 이미지 분류 모델은 Input size=260x260인 EfficientNet-V2이다. 학습은 TensorFlow가 제공하는 Coding tutorial ‘Retraining an image classifier’를 토대로 진행했다 [7].


### [Steps]
  * [1) 전체 파일 이미지화 : IC(Incremental Coordinate)](#1-전체-파일-이미지화--icincremental-coordinate)
    + [Code : 01_bin_visualization.ipynb](https://github.com/khudev-ksw/malware-dectection-with-ml/blob/main/01_bin_visualization.ipynb)
    + [(1) 좌표화](#1-좌표화)
    + [(2) 정규화](#2-정규화)
    + [(3) 실험결과](#3-실험결과)
  * [2) 좌표제거 방법](#2-좌표제거-방법)
    + [Code : 02_coordinates_removal.ipynb](https://github.com/khudev-ksw/malware-dectection-with-ml/blob/main/02_coordinates_removal.ipynb)
    + [(1) 좌표분석 및 제안방법](#1-좌표분석-및-제안방법)
    + [(2) 구현 : (0,0) 제거](#2-구현--00-제거)
    + [(3) 구현 : (0,0), (255,255), (0,8), (32,32), (0,255) 제거](#3-구현--00-255255-08-3232-0255-제거)
    + [(4) 생성 이미지 비교](#4-생성-이미지-비교)
  * [3) 실험 결과 및 분석](#3-실험-결과-및-분석)
    + [(1) 실험 결과 비교](#1-실험-결과-비교)
    + [(2) 분석 및 한계점](#2-분석-및-한계점)

### 1) 전체 파일 이미지화 : IC(Incremental Coordinate)
![figure02_IC](https://user-images.githubusercontent.com/41164017/173774149-30aa9780-5a1b-4695-9e91-370e292e2fe9.png)
프로그램 바이너리의 2 Bytes를 (1 Byte, 1 Byte) Pair로 대응시키는 방법이다.

#### (1) 좌표화
프로그램 바이너리에서 필요 부분 특정하고, 해당 부분의 시작부터 2 Bytes(1 Byte, 1Byte) 단위로 읽어 들인다. 각 Byte는 [0~255]로 표현 가능하며 각 2 Bytes는 (0, 0) ~ (255, 255) 좌표평면에 대응될 수 있다. 256x256 좌표평면 배열을 별도로 만들고 좌표평면에 대응되는 2 Bytes 바이너리가 발생할 경우, 해당 좌푯값을 1 증가시킨다. 바이너리를 끝까지 읽어 들이면 좌푯값을 가진 256x256 좌표평면을 얻을 수 있다.

```
f = open('[YOUR-FILE-PATH]', 'rb')
data = f.read()
f.close()

image_coordinate = np.array([[0]*256]*256)

st = time.time()

data_idx = 0

for i in tqdm(range(int(bin_length/2))) :
    image_coordinate[data[data_idx+1]][data[data_idx]] += 1
    data_idx += 2

# in case of odd length -> (last value, 0)=(x,y)
if bin_length%2!=0 :
    print("it's odd!")
    image_coordinate[0][data[-1]] += 1

et = time.time()
print(f"byte to coordinate : {et-st:.5f} sec")

print(image_coordinate)
```

#### (2) 정규화
생성된 좌푯값은 [0\~255] 범위를 벗어날 수 있기 때문에 아래와 같은 MinMax 정규화를 통해 모든 좌푯값을 [0\~1] 범위의 값으로 변환한다. [0~1]로 변환된 좌푯값에 255를 곱하고 floor 연산을 취하면 각 좌표의 최댓값이 255인 grayscale 이미지를 얻을 수 있다. 필요에 따라 이미지를 resize한다.

```
cmax = np.max(image_coordinate)
cmin = np.min(image_coordinate)
print(cmax, cmin)

# Scaling formula = (X-Xmin) / (Xmax - Xmin)
minmax_scaled_coordinate = (image_coordinate-cmin) / (cmax-cmin)

minmax_scaled_coordinate *= 255
minmax_scaled_coordinate = np.floor(minmax_scaled_coordinate)
print(minmax_scaled_coordinate)

coordinate_np = np.array(minmax_scaled_coordinate, dtype=np.uint8)
bin_image = Image.fromarray(coordinate_np)
```

#### (3) 실험결과
<img width="849" alt="figure08_coordinates_experiments" src="https://user-images.githubusercontent.com/41164017/173777527-e03357fc-e1fc-433b-bc2f-3c620acae6e3.png">
안드로이드 애플리케이션 전체를 이미지화하여 (Epoch=300, Learning rate=0.0001)로 학습시켰다. 위 그림에서 볼 수 있듯이 해당 학습을 통해 0.7002의 정확도(Accuracy)를 얻을 수 있었다. 학습량에 따라 정확도가 높아질 것이라 기대했지만 정확도는 0.7에 수렴하고 있으며, 이는 실제 적용되기에는 낮은 수치라는 것을 알 수 있다.

### 2) 좌표제거 방법
#### (1) 좌표분석 및 제안방법
애플리케이션 전체를 그대로 이미지화했을 때, 정확도가 낮았기에 추가적인 전처리를 통한 정확도 향상이 필요했다. 좌표화하는 과정에서 특정 좌푯값이 비정상적으로 높게 나타나는 것을 확인했는데, 이는 정규화 과정에서 MAX값을 매우 크게 만들어 상대적으로 작은 좌푯값이 floor 연산에서 손실되는 결과를 가져온다. 따라서 본 연구에서는 각각의 프로그램에서 가장 큰 값을 가지는 좌푯값을 제거하여 좌표 손실을 방지하는 <u>**좌표 제거 방법**</u>을 제안한다.

좌표 제거를 위해서는 전체 애플리케이션에서 어떤 좌표가 MAX값을 많이 가지게 되는지 확인해야 한다. MAX 좌표를 많이 가지는 빈도 순서를 적용하여 제거할 좌표를 선택했다. 최종적으로 (0,0), (255,255), (0,8), (32,32), (0,255), 총 5개의 좌표를 제거한 후 정규화를 진행하여 다른 좌푯값의 손실 정도를 줄였다.

#### (2) 구현 : (0,0) 제거
```
# Remove [0][0]
image_coordinate_rz = image_coordinate
image_coordinate_rz[0][0] = 0
print(image_coordinate_rz)

cmax_rz = np.max(image_coordinate_rz)
cmin_rz = np.min(image_coordinate_rz)
print(cmax_rz, cmin_rz)

# Scaling formula = (X-Xmin) / (Xmax - Xmin)
minmax_scaled_coordinate_rz = (image_coordinate_rz-cmin_rz) / (cmax_rz-cmin_rz)
minmax_scaled_coordinate_rz *= 255
minmax_scaled_coordinate_rz = np.floor(minmax_scaled_coordinate_rz)
print(minmax_scaled_coordinate_rz)

coordinate_np_rz = np.array(minmax_scaled_coordinate_rz, dtype=np.uint8)
bin_image_rz = Image.fromarray(coordinate_np_rz)

```

#### (3) 구현 : (0,0), (255,255), (0,8), (32,32), (0,255) 제거
```
# Remove 5 coordinates include [0][0]
image_coordinate_ra = image_coordinate
image_coordinate_ra[0][0] = 0
image_coordinate_ra[255][255] = 0
image_coordinate_ra[0][8] = 0
image_coordinate_ra[32][32] = 0
image_coordinate_ra[0][255] = 0

cmax_ra = np.max(image_coordinate_ra)
cmin_ra = np.min(image_coordinate_ra)
print(cmax_ra, cmin_ra)

# Scaling formula = (X-Xmin) / (Xmax - Xmin)
minmax_scaled_coordinate_ra = (image_coordinate_ra-cmin_ra) / (cmax_ra-cmin_ra)
minmax_scaled_coordinate_ra *= 255
minmax_scaled_coordinate_ra = np.floor(minmax_scaled_coordinate_ra)

coordinate_np_ra = np.array(minmax_scaled_coordinate_ra, dtype=np.uint8)
bin_image_ra = Image.fromarray(coordinate_np_ra)

```
#### (4) 생성 이미지 비교
<img width="833" alt="figure09_2way coordinates removal" src="https://user-images.githubusercontent.com/41164017/173777930-4bc998e8-d7cb-4636-95a7-9c53e416b5db.png">
위 그림은 (0,0)과 앞서 선택한 4개의 좌표를 제거하기 전, 후의 이미지 변화를 나타내고 있다. 좌표 제거 전, 후의 이미지 변화가 뚜렷하게 나타나며 (0,0)을 포함한 5개의 좌표를 모두 제거했을 때 가장 선명한 이미지를 볼 수 있다. 이를 통해 좌표 제거 전 정규화 과정에서 손실되었던 좌표 상당수가 손실되지 않게 된다는 것을 확인할 수 있다.


### 3) 실험 결과 및 분석
#### (1) 실험 결과 비교
<img width="855" alt="figure10_coordinates_removal_beforeafter_experiments" src="https://user-images.githubusercontent.com/41164017/173781526-6e4b17b7-c143-424f-8ffc-acee5f26f7be.png">
안드로이드 애플리케이션을 좌표화하고 앞서 선택한 5개 좌표를 제거하기 전, 후 이미지화한 경우를 학습한 결과이다. 두 실험 모두 (Epoch=300, Learning rate=0.0001)로 진행되었다. 그 결과, 좌표 제거 전 이미지화의 최종 정확도는 0.7002, 5개 좌표 제거 후 이미지화의 최종 정확도는 0.7973으로, 좌표를 제거하여 정확도가 0.0971 향상된 것을 확인할 수 있었다.

#### (2) 분석 및 한계점
전체 파일을 이미지화했을 경우 예측 정확도가 낮게 나왔기에 데이터에 추가적인 전처리를 진행하였다. (0,0)을 포함한 5개의 좌표를 제거한 데이터를 이미지화하여 실험을 진행했을 때, 좌표 제거 전 데이터를 이미지화한 경우보다 예측 정확도가 약 9% 높아졌음을 확인하였다. 이와 같이 특징 추출에 비해 간단한 전처리 방법을 적용함으로써 예측 정확도를 향상시켰고, 이를 통해 cost-effective한 악성 안드로이드 애플리케이션 탐지 시스템 개발에 도움을 줄 수 있을 것이라 기대한다.

그러나 실제 적용되기에는 낮은 정확도, 제거할 좌표 선택 기준, 바이너리의 의미적인 관점에서 봤을 때 좌표를 제거해도 되는가에 대한 의문점이 남는다. 따라서 위와 같은 점에 유의하여 향후 추가적인 이미지화 기법 및 다양한 분류 모델의 적용 등을 통해 데이터 전처리 과정을 간소화하고 예측 정확도를 높일 수 있는 cost-effective한 방안에 대한 연구를 이어나갈 예정이다.



## 참고문헌
- [1] 김형겸, 한석민, 이수철, 이준락, “딥러닝 기술을 활용한 멀웨어 분류를 위한 이미지화 기법”, 인터넷 정보학회논문지, Vol.19, No.5, 67-75, 2018.
- [2] 박지현, 김태옥, 신유림, 김지연, 최은정, “악성코드의 이미지 기반 딥러닝을 위한 전처리 방법 설계 및 개발”, 멀티미디어학회 논문지, Vol.23, No.5, 650-657 2020.
- [3] 김진섭, 김연어, 우균, “기계학습을 이용한 안드로이드 악성코드 탐지 기법”, 한국컴퓨터종합학술대회 논문집, 2018.
- [4] 강성은, 응웬부렁, 정수환, “머신러닝을 이용한 권한 기반 안드로이드 악성코드 탐지”, 정보보호학회 논문지, Vol.28, No.3, 617-623, 2018.
- [5] 강진원, 이수진, “네트워크 트래픽 이미지화를 통한 안드로이드 악성코드 탐지”, 정보과학회논문지, Vol.47, No.8, 761-768, 2020.
- [6] HCR Lab, 고려대학교 KU-CISC2018-Android, https://ocslab,hksecurity.net/Datasets/datachallenge2018/android, 2018.
- [7] TF Hub for TF2: Retraining an image classifier, https://colab.research.google.com/github/tensorflow/hub/blob/master/examples/colab/tf2_image_retraining.ipynb, 2021.

## 세부 내용 참고
좌표 제거 이미지화를 통한 악성 안드로이드 애플리케이션 탐지

(추후 KCC2022 논문 링크 추가)


## 이미지화 구현 time issue
![prev_ver](https://user-images.githubusercontent.com/41164017/163863034-8cba4db3-13f2-4845-b2a0-d91f4cd2e080.png)
   
![impr_ver1](https://user-images.githubusercontent.com/41164017/163863046-2421c8e5-18f3-4799-92e3-429da8cc897a.png)
